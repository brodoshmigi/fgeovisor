from abc import ABC, abstractmethod
from typing import Generator, Any, Dict, TypeVar

import pandas as pd

_N = TypeVar('_N')

class Download(ABC):

    @abstractmethod
    def download(self):
        pass


class Collections(ABC):
    """
    Есть одна вещая проблема.

    Client возвращает результат и мы уже определились, что для ассетов и коллекций,
    как минимум, у наса, должны быть разные link. Но, в чем же все таки проблема?
    
    Когда эта библиотека возвращает результат - он представляется ввиде объекта,
    т.к. содержит в себе кучу разных страниц с результатами, да, именно страниц.

    Это еще ничего, однако, получение таким образом результата превращается в
    <class ...>, что нас не интересует, так как нам из всех этих резульатов нужен,
    конечно, если нужен, тот, который подойдет под наши запросы. Объясняю почему:

    Если наша Q в поиске(кто не знаком с большой Q, просто знайте, это свободный параметр)
    будет равна landsat он выдаст абсолютно все коллекции, где хоть раз упоминалось это слово
    кто наблюдательный должен уже понять, что там содержится не только landsat,
    а, например, его смежные миссии, которые, соответственно, нам уже не подходят.

    Почему же не подходят? Мы ищем только те, которые содержат в себе каналы с 1 по 9.
    Но и не только это, еще, конечно, хотелось бы получать более точные результаты,
    а не все, что есть... Тем более там могут быть коллекции, которые уже морально устарели.
    Чисто логически, мы могли бы и не сортировать вообще ничего, получив коллекции, просто,
    скажем так, искать вхождения, да - это проблему бы решило, но мы, таким образом,
    можем и не попасть в то, что нам нужно.

    Ввиду чего возникает необходимость сортировки этих объектов по id, а это
    можно сделать только если использовать collections_as_... и все бы ничего,
    но авторы библиотеки реализовали эту функции как генератор, из-за чего,
    чтобы получить результат, нужно использовать очень большое количество циклов,
    что увеличивает время на совершение запроса.

    Да, может многопоточка это фиксит, но синхронная версия будет медленной ввиду этого.

    И эту проблему нужно решить, либо расширением существующего класса нашего,
    либо другими фокусами, конечно, можно ничего и не менять. Разница 1-3 сек.
    Ну либо можно получать равки и отправлять в другой класс, который уже будет фильтровать.
    """

    @abstractmethod
    def get_by_orgs(self) -> pd.DataFrame:
        """
        **Ищет каталоги, которые соответствуют нашему запросу.**
        
        Способы оптимизации:
            - Указание способов фильтрации в параметрах /search
            - Использование Pandas

        Returns:
            Dataframe ('id' | 'href'):
                DataFrame с отсортированными коллекциями
        """
        pass


class Assets(ABC):

    @abstractmethod
    def get(self) -> Generator[Any, Any, Any]:
        """
        **Ищет объекты, которые соответствуют нашему запросу.**
            
        Способы оптимизации:
            - Указание способов фильтрации в параметрах /search
            - Использование Numpy

        Args:
            inersects (GeoJson or Dict GeoJsonLike):
                Создает область интереса для поиска объектов
            query (List of JSON query params):
                Фильтрует изображения по заданым параметрам (ускоряет в 2 раза)
            max_items (int):
                Количество объектов, которое необходимо получить.

                Чем ближе значение к 1, или =1, тем быстрее выполняется скрипт. 

        Returns:
            Iterator (NDarray[Any]):
                Возвращает iterator с numpy массивом из объектов
        """
        pass

class NasaAuthBase(ABC):
    """
    Абстракция класса для классов аутентификации: Basic и Bearer.
    Грубо говоря, мы можем пойти в лес с топором, ножом или калашом.
    Что выберешь?

    Достаточно избыточно, но позволяет без лишних действий использовать
    Любой класс аутентификации. Плюсом можно добавить новых.
    """

    @abstractmethod
    def get_token(self) -> Dict[str, str]:
        pass

    @abstractmethod
    def reset_token(self) -> Dict[_N, _N]:
        return {}